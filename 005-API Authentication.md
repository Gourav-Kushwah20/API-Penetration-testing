# ğŸ” API Authentication

* API authentication is the process of verifying the identity of the user or application making an API request.

* Authentication answers the question:

* **Who are you? ğŸ‘¤**

* Authorization answers the question:

* **What are you allowed to do? ğŸ›¡**

---

## ğŸ”‘ Common API Authentication Methods

1. Basic Authentication
2. API Keys
3. OAuth 2.0
4. JWT (JSON Web Tokens)
5. Certificate-Based Authentication (Mutual TLS / mTLS)
6. HMAC (Hash-Based Message Authentication Code)
7. Session-Based Authentication

---

## ğŸ”“ 1. Basic Authentication

### âš™ï¸ How It Works

The client sends the username and password encoded in **Base64** inside the `Authorization` header.

#### ğŸ“Œ Example

```http
Authorization: Basic dXNlcjpwYXNzd29yZA==
```
(Base64 of `user:password`)

### âœ… Pros

* Very simple to implement
* Suitable for internal or low-security APIs
* Useful for testing environments

### âŒ Cons

* Credentials are sent with every request
* Not secure without HTTPS
* Vulnerable to credential leakage if intercepted

### ğŸ›¡ Security Notes

* Must always be used over **HTTPS**
* Avoid for public production APIs
* Susceptible to brute force if no rate limiting

---
## ğŸ— 2. API Keys

### âš™ï¸ How It Works

* Each client receives a unique API key.
* The key is sent in:

  * ğŸ“© Header
  * ğŸ” Query parameter
  * ğŸ“¦ Request body (less common)

#### ğŸ“Œ Example

```http
GET /api/data
x-api-key: abc123xyz
```

### âœ… Pros

* Simple implementation
* Good for service-to-service communication
* Useful for read-only APIs

### âŒ Cons

* Static credential
* No built-in user identity
* Limited fine-grained authorization
* Often exposed in client-side JavaScript


### âš ï¸ Security Risks

* API key leakage in source code
* Exposure in browser DevTools
* Logging exposure
* No expiration by default

---

## ğŸŒ 3. OAuth 2.0

* OAuth 2.0 is an **authorization framework**, not strictly an authentication protocol.
* It allows third-party applications to access resources **without exposing user credentials**.

### âš™ï¸ How It Works

1. User authenticates with the authorization server.
2. Server issues an access token.
3. Client uses the access token in API requests.

#### ğŸ“Œ Example

```http id="ejb0mb"
Authorization: Bearer access_token_here
```

### ğŸ”„ Common Grant Types

* Authorization Code (most secure for web apps)
* Client Credentials (machine-to-machine)
* Device Code
* Refresh Token
* (Implicit and Password grants are deprecated in modern implementations)

### âœ… Pros

* Granular access control via scopes
* Token expiration and refresh support
* Widely adopted standard

### âŒ Cons

* Complex implementation
* Misconfiguration risks
* Token leakage risk

### ğŸš¨ Security Risks

* Missing state validation
* Token reuse
* Open redirect vulnerabilities
* Improper scope validation

---

## ğŸŸ 4. JWT (JSON Web Tokens)

* JWT is a compact, URL-safe token format used for authentication and authorization.
* JWTs are self-contained tokens.

### ğŸ§© Structure of a JWT

A JWT consists of three parts:

```
Header.Payload.Signature
```

### 1ï¸âƒ£ Header

Specifies:

* Token type
* Signing algorithm

#### ğŸ“Œ Example

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

### 2ï¸âƒ£ Payload

Contains claims:

* User ID
* Roles
* Expiration time
* Issuer

#### ğŸ“Œ Example

```json
{
  "sub": "101",
  "role": "admin",
  "exp": 1700000000
}
```


### 3ï¸âƒ£ Signature

Generated by signing the header and payload using a **secret** or **private key**.

### âœ… Pros

* Stateless
* No server-side session storage
* Fast validation
* Suitable for microservices

### âŒ Cons

* Cannot be revoked easily unless tracked
* Large token size if many claims included
* Not encrypted by default (only signed)

### ğŸš¨ Common Security Risks

* Algorithm confusion attacks
* Accepting `alg: none`
* Weak secret keys
* Storing sensitive data in payload
* No expiration validation

---

## ğŸ” 5. Certificate-Based Authentication (Mutual TLS / mTLS)

### âš™ï¸ How It Works

* Both client and server present digital certificates.
* The server verifies the client certificate before allowing access.


### âœ… Pros

* Very strong authentication
* Cryptographic identity verification
* Ideal for sensitive environments


### âŒ Cons

* Complex certificate lifecycle management
* Revocation handling required
* Operational overhead


### ğŸŒ Common Use Cases

* ğŸ¦ Banking systems
* ğŸ¢ Enterprise integrations
* ğŸ§© Microservice internal communication

---

## ğŸ” 6. HMAC Authentication

HMAC uses a **shared secret** to sign requests.

### âš™ï¸ How It Works

1. ğŸ” Client creates a hash using:

   * ğŸ”‘ Secret key
   * ğŸ“¦ Request components (method, path, timestamp, body)

2. âœ… Server recalculates and verifies the hash.

#### ğŸ“Œ Example Header

```http
Authorization: HMAC signature_here
```

### âœ… Pros

* Ensures integrity
* Prevents tampering
* Protects against replay attacks (with timestamp)


### âŒ Cons

* Shared secret management required
* Computational overhead

### ğŸŒ Common Use Cases

* â˜ï¸ Cloud APIs
* ğŸ’³ Financial APIs
* ğŸ” AWS-style request signing

---

## ğŸª 7. Session-Based Authentication

### âš™ï¸ How It Works

1. User logs in.
2. Server creates a session ID.
3. Session ID stored server-side.
4. Client stores session ID in a cookie.
5. Cookie sent with each request.

### âœ… Pros

* Easy to revoke sessions
* Server controls session lifecycle
* Common in traditional web apps

### âŒ Cons

* Not scalable without distributed session store
* Not ideal for pure REST APIs
* Requires server-side state

---

## ğŸª Cookie-Based Authentication

Cookie-based authentication relies on storing a session identifier in a browser cookie.


### ğŸ”„ Flow

1. User logs in.
2. Server creates session ID.
3. Session ID sent in `Set-Cookie` header.
4. Browser stores cookie.
5. Cookie automatically sent with future requests.

### ğŸ“Œ Example

```http id="5u7on7"
Set-Cookie: sessionId=abc123; HttpOnly; Secure
```

### ğŸ›¡ Best Practices

* Use HTTPS only
* Set `Secure` flag
* Set `HttpOnly` flag
* Use `SameSite` attribute
* Use strong random session IDs
* Set expiration time
* Invalidate session on logout
* Rotate session ID after login

### ğŸš¨ Common Security Risks

* ğŸ•µï¸ Session hijacking
* ğŸ’‰ Cross-Site Scripting (XSS)
* ğŸ” Cross-Site Request Forgery (CSRF)
* ğŸ­ Session fixation
* ğŸ”¢ Predictable session IDs

---

## ğŸŸ Token-Based Authentication

Token-based authentication uses a token instead of a server-side session.

### ğŸ”„ Flow

1. ğŸ‘¤ User logs in.
2. ğŸŸ Server generates token.
3. ğŸ’¾ Client stores token (local storage or cookie).
4. ğŸ“¡ Client sends token in header.

### ğŸ“Œ Example

```http
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

### âœ… Advantages

* Stateless
* Scalable
* Suitable for APIs and SPAs
* Works well with microservices

### ğŸ›¡ Security Best Practices

* Always use HTTPS
* Set expiration time
* Validate signature
* Validate issuer and audience
* Implement token rotation
* Invalidate on logout
* Store securely (avoid `localStorage` if possible)

### âš ï¸ Common Risks (Token-Based Authentication)

* Token theft via XSS
* Long-lived tokens
* Missing expiration validation
* Accepting unsigned tokens
* Storing sensitive claims inside payload

---

## ğŸª Cookie-Based vs ğŸŸ Token-Based Authentication

| Feature          | ğŸª Cookie-Based  | ğŸŸ Token-Based                     |
| ---------------- | ---------------- | ---------------------------------- |
| **Server State** | Stateful         | Stateless                          |
| **Storage**      | Browser cookie   | Header or storage                  |
| **Scalability**  | Limited          | High                               |
| **Revocation**   | Easy             | Harder                             |
| **CSRF Risk**    | Higher           | Lower (if header-based)            |
| **XSS Risk**     | Lower (HttpOnly) | Higher (if stored in localStorage) |

---

### ğŸ§­ Choosing the Right Authentication Method

The correct choice depends on:

* ğŸ— Application type
* ğŸ” Security requirements
* ğŸ“ˆ Scalability needs
* ğŸ§© Architecture (monolith vs microservices)
* ğŸ”— Third-party integration requirements

 ğŸ“Œ General Guidance

* ğŸ¢ **Internal APIs** â†’ mTLS or HMAC
* ğŸŒ **Public APIs** â†’ OAuth 2.0 + JWT
* ğŸ–¥ **Traditional web apps** â†’ Session + Cookies
* ğŸ§¬ **Microservices** â†’ JWT or mTLS
* ğŸ›¡ **High-security environments** â†’ mTLS + OAuth

---
